\lhead[]{}
\rhead[]{}
\chead[DevOps再考]{DevOps再考}

# DevOps再考

## DevOpsとは

 DevOpsとは、開発を示す「Dev」と運用を示す「Ops」の合成語です。
 このためDevOpsを説明する時には「開発担当者（Dev）と運用担当者（Ops）が
 連携して協力し合う開発手法のこと」という説明をされたりします。

DevOpsという言葉が生まれたきっかけは、2008年にカナダのトロントで開かれた「Agile2008」^[[https://www.agilealliance.org/agile2008/
](https://www.agilealliance.org/agile2008/
)]
というカンファレンスです。ベルギーのITインフラを専門とするコンサルタントの
Patrick Debois氏による「Agile Infrastructure and Operations」^[[http://www.jedi.be/presentations/agile-infrastructure-agile-2008.pdf](http://www.jedi.be/presentations/agile-infrastructure-agile-2008.pdf)]という
セッションの中で、データセンターの移行というインフラ構築のプロジェクトに
アジャイル開発のプラクティスをどう適用するかという問題意識とその実践をまとめた発表です。

これを受けて2009年、米国サンノゼで開催されたVelocity 2009^[[https://conferences.oreilly.com/velocity/velocity2009
](https://conferences.oreilly.com/velocity/velocity2009
)]に
FlickrのエンジニアであるJohn Allspaw氏, Paul Hammond氏が「10+ Deploys per Day: Dev and Ops Cooperation at Flickr」という発表を行います。
このこのプレゼンテーションをベルギーからストリーミングで視聴していたPatrick Debois氏が、
「Devopsdays」というイベントを開く事を思い立ち、それが本格的なDevOpsムーブメントの始まりと
なったとされています。[@Edwards2012] ^[[http://itrevolution.com/the-history-of-devops/](http://itrevolution.com/the-history-of-devops/)] ここに至るまでの流れは@marubinotto氏 ^[[https://twitter.com/marubinotto](https://twitter.com/marubinotto)] によって「DevOpsの起源とOpsを巡る対立」 ^[[https://ubiteku.oinker.me/2015/07/01/devops%E3%81%AE%E8%B5%B7%E6%BA%90%E3%81%A8ops%E3%82%92%E5%B7%A1%E3%82%8B%E5%AF%BE%E7%AB%8B/](https://ubiteku.oinker.me/2015/07/01/devops%E3%81%AE%E8%B5%B7%E6%BA%90%E3%81%A8ops%E3%82%92%E5%B7%A1%E3%82%8B%E5%AF%BE%E7%AB%8B/)] としてまとめられています。

もともとソフトウェア開発は、「キーボードとディスプレイがあれば仕事が出来る」などと評されるように、
その対象となるドメインは、ソフトウェアとそれを構成するプログラミングの世界にある程度閉じて
います。それに対してインフラ構築やその運用は、サーバーやネットワーク機器、回線設備など、ハードウェアと
関わり合いを持つため、ソフトウェア開発の職能とはその性格を異にしています。

パブリッククラウドが普及する前、大規模なソフトウェア開発のプロジェクトというのは、サーバーやネットワーク機器を
収容するためのデータセンター内の配置や、場合によっては施設の建築までを領域として含んでいました。

また筆者が若手エンジニアだったころのソフトウェア運用の現場というのは、定められた運用スケジュールに従って
ジョブスケジューラーを起動し、バッチプログラムの実行結果を確認したり、業務部署に帳票を
配布するための専任のオペレーターが勤務しているのが常でした。

そのため、インフラ構築やシステム運用のプロセスは、機器のセットアップや、定常業務の運用など、プロセス中に
人間が行う作業が介在することを前提とし、それを最適化する方向で発展してきました。

それに対しソフトウェア開発のプロセスは、アジャイルソフトウェア開発宣言(アジャイルマニフェスト)の
「包括的なドキュメントよりも動くソフトウェア」という言い回しに象徴されるように、成果物としての
ソフトウェアをどう構築するかという観点で発展を続けてきました。
その中で特徴的なのは、「バージョン管理、テスティング、自動化」というプラクティスに代表される、
ソフトウェア開発そのものを技術的かつソフトウェア工学的なアプローチによって最適化していくアプローチです。

DevOpsという言葉が指すものには、どのステークホルダーがどのような視野から領域を捉えるかによって、
様々な意味を含んでいます。しかし少なくともDevOpsというムーブメントの黎明期においては、インフラ構築や
システム運用のプロセスに、ソフトウェア開発のアプローチの知見を取り入れることにより、プロセスを
どう改善していけるかという着眼点が含まれていました。

もちろん技術面の発達によりソフトウェア運用のプロセスが合理化されていくなかで、開発プロセスを
担当するソフトウェアエンジニアがインフラ構築や運用などの分野をある程度担うことも可能になってきました。
また、インフラ構築にプログラミングの技法を導入する「Infrastructure as Code」に代表されるように、
インフラの領域にソフトウェア開発のスキルが求められる流れは止められないものとなっています。

しかし、インフラ構築に対する継続的インテグレーションや、アプリケーションのデプロイの自動化、
Blue-Green Deployment（や～～）など、インフラ構築に関する技術の進展は、アプリケーションと自動化
されたインフラ層のつなぎ目の部分に、新たな専門性を生み出しました。

デプロイが自動化されればその分労働力は省略化されますが、それを可能にするだけの技術レベルを
組織を維持するには、一定レベル以上の技術者が「複数」必要です。

## DevとOpsの対立はどこからうまれるのか

DevOpsを語る文脈の中では、Devは新機能の追加など、変化に積極的であり、
Opsはシステムの安定運用のために保守的であるとされます。

そのため、Devが能動的に活動しようとしたときに、それを様々な理由から
抑制するOpsという観点で、DevOpsを巡る背景は語られがちです。

> これではいい結果が出るわけがない。通常、そのようなソフトウェアは安定せず、
> 使いものにならないので、早くリリースしてくれと言っていた人々でさえ、
> これはリリースすべきじゃなかったと言い出す。
> そして、できの悪いコードのためにサーバーを何度も再起動し、
> 外の世界からそれがいかにひどい代物かがわからにようにするために必要ならことなら超人的なことまでやって、
> 徹夜でがんばらければいけなくなるのはいつもIT運用なのだ。

DevOpsの中でのDevとOpsの関係を考えた時に、システム運用のプロセスに徹底した自動化を
入れることにより、ソフトウェア運用のプロセスから手作業が介在する箇所を排して、
運用担当者なしでの運用を目指す、NoOpsという考えがあります。

しかし、先ほど述べたDevOpsというムーブメントの発端からわかるように、DevOpsとは、
「Devのスピード感のために、その障壁となるOpsを排斥する」という思想ではありません。

また、「動くコードに手を入れるな」という言葉に象徴されるように、
Devがコードの構成に手を入れた場合にその影響範囲を読み切れないことから、
コードベースに積極的に手を入れることに慎重な態度を見せることもまたよくあることです。

また、今日のWebアプリケーションのセキュリティーを巡る動向の中では、
脆弱性が公知になってから稼働しているシステムがターゲットになる期間が短くなる傾向があります。

その際、Opsは運用の中から生まれる課題を解決するためにシステムの素早い改修を望んでいるわけです。


このため、アプリケーション層のミドルウェアやフレームワークを迅速にバージョンアップすることが
運用要件としてもとめられますが、この際にDevがリグレッションテストの工数などの理由により
及び腰になる場合もあります。

またテストやデプロイ自動化や、Infrastructure as Codeに代表されるように、
プロダクトコードとインフラの接合部となる部分にプログラミングがカバーする領域が
拡大したことにより、DevとOps双方に新しい課題が生まれています。

Devがデプロイや○○など、Opsの領域をカバーすることが増えていく中で、Opsの領域が
有していたノウハウが引き継がれず、ノウハウの断絶が今日の現場では生じています。
例えば作業時のダブルチェックや、バックアップ処理などの運用の定常処理に対する監視
などです。

作業時のダブルチェックは、とかくソフトウェアエンジニアの省略化を是とする価値観
からは批判されがちですが、手順書に従って作業を行う際に、作業を行う側と、作業が
手順通りに行われていることを確認するという手順を分担するという考えは、れっきとした
合理性を有しています。

また開発プロセスの中で、運用に関する要件が未確定な状態で、ソフトウェア開発者が
運用の領域の課題をソフトウェアの領域でカバーしようとすることによる、
オーバーエンジニアリングの問題が存在します。

事前に、それが問題なく動作することを確認することが難しい
運用要件がいらずらに自動化されることにより、実運用の現場でその条件が発動
した場合に二次被害が発生する場合もあります。

また、インフラ構築や運用業務を自動化する中で、実装を担当する技術者に
ソフトウェア開発が乏しいことによる、可読性に書くコードや重複コードなどの
技術的負債が

- OpsがDevの知識を有しないことによる技術的負債
- Opsサイドのノウハウの断絶(例・バックアップの監視、手動作業時のダブルチェック)

## システム開発とボトルネック

先ほど述べてきたように、DevOpsを巡る対立は、Devがシステムの改修に積極的で、Opsが
保守的であることに端を発するものではありません。

筆者がここまで見てきた現場の経験からすると、サービス運営に関わる各々の主体感の
対立は、組織間で課題に対応する上でのリードタイムの不一致から発生するものです。

ソフトウェアがデリバリーされる過程の中では、リードタイムがもっともかかる工程が、
デリバリーされるまでの時間を決定づける最も重要な要素となります。

システム開発の各工程を担う主体の中で、成果物を担うためのリードタイムにずれがあると、
個別工程の改善が最終的にデリバリーするまでの時間の短縮に結びつかず、個別最適になる
状況が発生します。

また成果物を引き渡す前工程、後工程の間でのリードタイムの著しいずれは、
各担当者の間の心理的軋轢を生み出します。

ソフトウェア開発とデリバリーを巡る工程の中でのボトルネックの箇所は、技術の進展により、
異動を続けてきました。

ソフトウェアのデバッグを行う上でグラフィカルなデバッガーを使うことが普及しておらず、
コード補完などのインテリジェンスな機能を有しないテキストエディター
でコーディングすることが一般的だった時代がありました。

この中では、ソフトウェア開発の中で最大のボトルネックとなる箇所は、プログラミングや
デバッグなどの、いわゆる開発工程でした。そこでの手戻りのリスクを低減するために、
ソフトウェアを実装する上での要件を予め厳密に定義し、プログラムの詳細設計や机上
デバッグに一定の工数を割くため、工程の進行はウォーターフォールとなります。

その後、統合開発環境(IDE)によるインタラクティブなデバッガーを用いた開発が
当然のものとなり、プログラミングの生産性が改善されると、ボトルネックはその後工程となる
テストやデプロイの部分となってきました。

その課題に対処するため、テスト自動化や継続的デリバリー(CI)などのプラクティスによって
テストやデプロイの生産性が改善されると、インフラの構築やその運用がネックになってきました。

そしてそのインフラ部分のボトルネックを解消するため生まれたのが仮想化技術、そしてクラウドであり、
その特徴を生かしたのがInfrastrcture as Codeです。

技術の進展によりボトルネックが移動していく中で、リードタイムのずれを調整し、フィードバックサイクルを
短縮するには、○○することがが必要になります。


>「継続的デリバリーは、コードのリリースを改善するための技術的な手法をすべてカバーしようとしている。
> 一方、DevOpsは文化の変革に焦点を当てようとしている。筆者は、企業文化を変えずに技術的な変革を実現
> することはできないと考えている。そのため、本書では、DevOpsを『開発が新たに作成したコードを顧客に
> 届ける際の効率を改善するプロセスや手法』と定義する。」
``

その点において、DevOpsとは「フィードバックサイクルを短縮し、価値あるプロダクトを作り出すために、
開発とデリバリーのプロセスを全体最適化すること」と定義することができます。

## SoEとSoR

ITサービス運営におけるアーキテクチャーを考える上で、「SoE」「SoR」という概念が近年広く使われるように
なっています。これは「キャズム」の著者、ジェフェリー・ムーア氏が2011年に発表したホワイトペーパー、
「Systems of Engagement and The Furute of Enterprise IT」によって広まった概念です。


DevOpsの文脈を語る上でSoEとSoRの関係は、

SoEは要件に不確定要素があり頻繁に変更が入るため、アジャイル開発などの反復型開発プロセスを採用し、リリースから素早いフィードバックを得られるようにする。

SoRは要件が確定しており変更も頻繁でないため、ウォーターフォールの開発プロセスを採用する。

というように分類されます。

しかし、

- ビジネスの展開の足を引っ張るSoR

SoE側は短期間でKPIの結果を出すことに汲汲とした結果、ユーザーからも変更の意味に疑問を投げかけるような
画面デザインの細かい変更に少なくないリソースを投入するような場合もあります。


- アプリは、変更は頻繁でなくて良い、品質を安定させろ

SoRはビジネスを支援するためにアジリティーを意識すべきだし、SoEは刹那的なKPIに踊らされずに長期的な視野を持つべきである、ということになります。

## 現実化する「何もしてないのに動かなくなりました」

## 頻繁にリリースすればDevOpsなのだろうか

- 試行のためのサイクルを細かく回す、というのはわかる
- それならば、開発環境のデプロイをデイリーから徐々に短くしていき、最終的にA/Bテストに行くというのならわかる
- アプリではバージョンアップが頻繁なのは嫌気される

## 「フルスタックエンジニア」とは何だったのか

アプリケーションの構築、アーキテクチャーの策定、UIデザインからUXに至るまで幅広い領域を
単独のエンジニアがカバーするフルスタックエンジニアという考えがあります。
もともとこれは、スタートアップに代表されるような比較的短期間の開発の中で、素早く
サービスをローンチして、投資の回収を可能にすることに最適化したスキームです。

もちろんSRE(Site Reliability Engeneering)に代表されるように、これまでプロセスの
中に人間が介在することを前提としてきたサービス運用の現場にソフトウェアエンジニア
リングのアプローチを導入していく流れは止められないものとなっています。

ですが、それはチーム全体として、より高いエンジアリングの水準を求めるものであり、
単にソフトウェアエンジニアが、インフラ構築やサービス運用の領域を担うようになれば
達成できるものではありません。



## 「実装屋」の役割
...